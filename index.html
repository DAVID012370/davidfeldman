<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DJ Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro",
        sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #141927, #050609 60%);
      color: #f5f5f5;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem 1rem;
    }

    .app {
      width: 100%;
      max-width: 1280px;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .brand-title {
      font-size: 1.6rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .brand-sub {
      font-size: 0.8rem;
      opacity: 0.7;
    }

    .top-right {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .toggle-pill {
      display: inline-flex;
      padding: 0.3rem;
      background: rgba(255, 255, 255, 0.04);
      border-radius: 999px;
    }

    .toggle-pill button {
      padding: 0.35rem 1.1rem;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: #f5f5f5;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.15s ease, box-shadow 0.15s ease,
        color 0.15s ease;
    }

    .toggle-pill button.active {
      background: linear-gradient(135deg, #ff4bda, #ff9f5b);
      box-shadow: 0 0 15px rgba(255, 90, 200, 0.6);
      color: #080814;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      justify-content: space-between;
    }

    .controls-left,
    .controls-right {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
    }

    label {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-right: 0.25rem;
    }

    .select-pill {
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(11, 12, 20, 0.9);
      color: #f5f5f5;
      font-size: 0.8rem;
      cursor: pointer;
      min-width: 90px;
    }

    .btn-pill {
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: none;
      background: rgba(255, 255, 255, 0.04);
      color: #f5f5f5;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.15s ease, box-shadow 0.15s ease,
        transform 0.1s ease;
      white-space: nowrap;
    }

    .btn-pill.primary {
      background: linear-gradient(135deg, #ff4bda, #ff9f5b);
      color: #080814;
      box-shadow: 0 0 12px rgba(255, 90, 200, 0.6);
    }

    .btn-pill.danger {
      background: radial-gradient(circle at top, #ff4b6b, #7b0d2b);
      color: #fff;
    }

    .btn-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.09);
    }

    .visualizer-wrapper {
      position: relative;
      border-radius: 26px;
      background: radial-gradient(circle at top, #11182a, #05060a 75%);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 24px 80px rgba(0, 0, 0, 0.65);
      overflow: hidden;
      padding: 1.5rem 1.5rem 1.2rem 1.5rem;
    }

    .drag-hint {
      position: absolute;
      top: 1.1rem;
      left: 1.75rem;
      font-size: 0.8rem;
      opacity: 0.7;
      pointer-events: none;
      user-select: none;
    }

    canvas {
      display: block;
      width: 100%;
      height: 460px;
      border-radius: 18px;
      background: radial-gradient(circle at top, #141a32, #05060b 70%);
    }

    .hud-footer {
      position: absolute;
      right: 1.9rem;
      bottom: 1rem;
      font-size: 0.7rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      opacity: 0.72;
    }

    .timeline-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.2rem;
      font-size: 0.75rem;
      opacity: 0.9;
    }

    .timeline-time {
      width: 2.6rem;
      text-align: center;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #34d2ff;
      box-shadow: 0 0 12px rgba(52, 210, 255, 0.8);
      cursor: pointer;
      border: 2px solid #040611;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #34d2ff;
      border: 2px solid #040611;
      cursor: pointer;
    }

    .transport-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 0.6rem;
      gap: 0.75rem;
    }

    .transport-left,
    .transport-middle,
    .transport-right {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .label-small {
      font-size: 0.75rem;
      opacity: 0.7;
    }

    .now-playing {
      font-size: 0.8rem;
      opacity: 0.85;
      text-align: center;
      margin-top: -0.3rem;
    }

    .now-playing span {
      opacity: 0.7;
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 900px) {
      canvas {
        height: 360px;
      }
      .visualizer-wrapper {
        padding: 1.15rem 1.1rem 1rem 1.1rem;
      }
      .hud-footer {
        right: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="brand-title">DJ VISUALIZER</div>
        <div class="brand-sub">Audio reactive visuals · enjoy :)</div>
      </div>
      <div class="top-right">
        <div class="toggle-pill" id="modeToggle">
          <button id="btnModeVisualizer" class="active">Visualizer</button>
          <button id="btnModeLogo">Logo</button>
        </div>
      </div>
    </header>

    <div class="controls-row">
      <div class="controls-left">
        <div>
          <label for="themeSelect">Theme</label>
          <select id="themeSelect" class="select-pill">
            <option>Neon</option>
            <option>Dark</option>
            <option>Sunset</option>
          </select>
        </div>
        <div>
          <label for="visualizerSelect">Visualizer</label>
          <select id="visualizerSelect" class="select-pill">
            <option>Bars</option>
            <option>Circle</option>
            <option>Waveform</option>
          </select>
        </div>
        <div>
          <label for="fxSelect">FX</label>
          <select id="fxSelect" class="select-pill">
            <option value="clean">Clean</option>
            <option value="glitch">Glitch</option>
          </select>
        </div>
        <div>
          <label for="fxStrengthSelect">FX strength</label>
          <select id="fxStrengthSelect" class="select-pill">
            <option value="soft">Soft</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <div>
          <button id="btnLogoUpload" class="btn-pill">Logo</button>
          <button id="btnLogoClear" class="btn-pill">Logo X</button>
          <input
            id="logoFileInput"
            type="file"
            accept="image/png,image/jpeg"
            class="hidden"
          />
        </div>
      </div>

      <div class="controls-right">
        <button id="btnDlPng" class="btn-pill primary">DL PNG</button>
        <button id="btnRec" class="btn-pill danger">REC</button>
        <button id="btnPerf" class="btn-pill">PERF</button>
        <button id="btnSave" class="btn-pill">SAVE</button>
        <button id="btnLoad" class="btn-pill">LOAD</button>
      </div>
    </div>

    <div class="visualizer-wrapper">
      <div class="drag-hint" id="dragHint">
        Drag &amp; drop audio or logo here.
      </div>
      <canvas id="visCanvas"></canvas>
      <div class="hud-footer" id="hudFooter">
        SPECTRUM · NEON · VISUAL + LOGO · BARS · FX CLEAN · SOFT
      </div>
    </div>

    <div class="now-playing" id="nowPlaying">
      Now Playing: <span>— none —</span>
    </div>

    <div class="timeline-row">
      <div class="timeline-time" id="timeCurrent">0:00</div>
      <input id="timeline" type="range" min="0" max="1" step="0.001" value="0" />
      <div class="timeline-time" id="timeTotal">0:00</div>
    </div>

    <div class="transport-row">
      <div class="transport-left">
        <button id="btnLoadTrack" class="btn-pill">Load Track</button>
        <button id="btnPlayPause" class="btn-pill primary">Play</button>
        <button id="btnClearAudio" class="btn-pill">Clear</button>
      </div>

      <div class="transport-middle">
        <span class="label-small">Vol</span>
        <input
          id="volumeSlider"
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.8"
          style="width: 120px"
        />
        <span class="label-small">Space = Play/Pause · P = Performance mode.</span>
      </div>

      <div class="transport-right">
        <button id="btnDlAudio" class="btn-pill primary">DL Audio</button>
      </div>
    </div>

    <audio id="audio" crossorigin="anonymous"></audio>
    <input
      id="audioFileInput"
      type="file"
      accept="audio/mpeg,audio/wav,audio/x-wav,audio/wave,audio/x-pn-wav"
      class="hidden"
    />
  </div>

  <script>
    // --- DOM references ---
    const canvas = document.getElementById("visCanvas");
    const ctx = canvas.getContext("2d");
    const audio = document.getElementById("audio");

    const themeSelect = document.getElementById("themeSelect");
    const visualizerSelect = document.getElementById("visualizerSelect");
    const fxSelect = document.getElementById("fxSelect");
    const fxStrengthSelect = document.getElementById("fxStrengthSelect");

    const btnModeVisualizer = document.getElementById("btnModeVisualizer");
    const btnModeLogo = document.getElementById("btnModeLogo");

    const btnLogoUpload = document.getElementById("btnLogoUpload");
    const btnLogoClear = document.getElementById("btnLogoClear");
    const logoFileInput = document.getElementById("logoFileInput");

    const btnDlPng = document.getElementById("btnDlPng");
    const btnRec = document.getElementById("btnRec");
    const btnPerf = document.getElementById("btnPerf");
    const btnSave = document.getElementById("btnSave");
    const btnLoad = document.getElementById("btnLoad");

    const dragHint = document.getElementById("dragHint");
    const hudFooter = document.getElementById("hudFooter");

    const nowPlaying = document.getElementById("nowPlaying").querySelector("span");

    const timeline = document.getElementById("timeline");
    const timeCurrent = document.getElementById("timeCurrent");
    const timeTotal = document.getElementById("timeTotal");

    const btnLoadTrack = document.getElementById("btnLoadTrack");
    const btnPlayPause = document.getElementById("btnPlayPause");
    const btnClearAudio = document.getElementById("btnClearAudio");

    const volumeSlider = document.getElementById("volumeSlider");
    const btnDlAudio = document.getElementById("btnDlAudio");
    const audioFileInput = document.getElementById("audioFileInput");

    // --- Canvas sizing ---
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // --- Audio context + analyser ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    let analyser = null;
    let sourceNode = null;
    const freqData = new Uint8Array(256);

    function ensureAudioContext() {
      if (!audioCtx) {
        audioCtx = new AudioContext();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        analyser.smoothingTimeConstant = 0.85;
      }
      if (!sourceNode) {
        sourceNode = audioCtx.createMediaElementSource(audio);
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);
      }
    }

    // --- State ---
    let visualizerModeActive = true;
    let logoModeActive = false;
    let performanceMode = false;

    let logoImage = null;
    let logoCanvas = document.createElement("canvas");
    let logoCtx = logoCanvas.getContext("2d");
    let logoScale = 1;

    let isRecording = false;
    let mediaRecorder = null;
    let recordedChunks = [];

    // --- Helpers ---
    function formatTime(seconds) {
      if (!isFinite(seconds)) return "0:00";
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return m + ":" + String(s).padStart(2, "0");
    }

    function updateHudFooter() {
      const theme = themeSelect.value.toUpperCase();
      const vis = visualizerSelect.value.toUpperCase();
      const fx = fxSelect.value.toUpperCase();
      const fxStrength = fxStrengthSelect.value.toUpperCase();

      const parts = [
        "SPECTRUM",
        theme,
        visualizerModeActive ? "VISUAL" : null,
        logoModeActive ? "LOGO" : null,
        vis,
        "FX " + fx,
        fxStrength,
      ].filter(Boolean);

      hudFooter.textContent = parts.join(" · ");
    }

    themeSelect.addEventListener("change", updateHudFooter);
    visualizerSelect.addEventListener("change", updateHudFooter);
    fxSelect.addEventListener("change", updateHudFooter);
    fxStrengthSelect.addEventListener("change", updateHudFooter);

    // --- Mode toggle (Visualizer / Logo) ---
    function syncModeButtons() {
      btnModeVisualizer.classList.toggle("active", visualizerModeActive);
      btnModeLogo.classList.toggle("active", logoModeActive);
      updateHudFooter();
    }

    btnModeVisualizer.addEventListener("click", () => {
      visualizerModeActive = !visualizerModeActive;
      if (!visualizerModeActive && !logoModeActive) {
        logoModeActive = true;
      }
      syncModeButtons();
    });

    btnModeLogo.addEventListener("click", () => {
      logoModeActive = !logoModeActive;
      if (!visualizerModeActive && !logoModeActive) {
        visualizerModeActive = true;
      }
      syncModeButtons();
    });

    syncModeButtons();

    // --- Logo loading ---
    function handleLogoFile(file) {
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        logoImage = img;
        // setup offscreen canvas
        const maxW = 420;
        const scale = Math.min(1, maxW / img.width);
        logoCanvas.width = img.width * scale;
        logoCanvas.height = img.height * scale;
        logoCtx.clearRect(0, 0, logoCanvas.width, logoCanvas.height);
        logoCtx.drawImage(
          img,
          0,
          0,
          img.width,
          img.height,
          0,
          0,
          logoCanvas.width,
          logoCanvas.height
        );
        logoScale = 1;
        logoModeActive = true;
        syncModeButtons();
      };
      img.src = url;
    }

    btnLogoUpload.addEventListener("click", () => logoFileInput.click());
    logoFileInput.addEventListener("change", (e) =>
      handleLogoFile(e.target.files[0])
    );

    btnLogoClear.addEventListener("click", () => {
      logoImage = null;
      logoCanvas.width = 1;
      logoCanvas.height = 1;
    });

    // --- Drag & drop (audio or logo) ---
    function isAudioFile(file) {
      return /^audio\//.test(file.type);
    }
    function isImageFile(file) {
      return /^image\//.test(file.type);
    }

    function handleDroppedFile(file) {
      if (isAudioFile(file)) {
        loadAudioFile(file);
      } else if (isImageFile(file)) {
        handleLogoFile(file);
      }
    }

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
      canvas.addEventListener(eventName, preventDefaults, false);
    });

    canvas.addEventListener("dragover", () => {
      dragHint.style.opacity = 0.2;
    });

    canvas.addEventListener("dragleave", () => {
      dragHint.style.opacity = 0.8;
    });

    canvas.addEventListener("drop", (e) => {
      dragHint.style.opacity = 0.8;
      const dt = e.dataTransfer;
      const file = dt.files[0];
      if (file) handleDroppedFile(file);
    });

    // Also use click on canvas to open appropriate picker depending on what
    // the user probably wants:
    canvas.addEventListener("click", () => {
      // If shift is held – upload logo; otherwise audio
      // (nice small hidden shortcut).
      // For normal click we still prefer audio (most common).
      audioFileInput.click();
    });

    // --- Audio loading ---
    function loadAudioFile(file) {
      const url = URL.createObjectURL(file);
      audio.src = url;
      audio.load();
      nowPlaying.textContent = file.name || "custom audio";
      ensureAudioContext();
      dragHint.textContent = "Drag & drop audio or logo here.";
      audio.play().catch(() => {});
      btnPlayPause.textContent = "Pause";
    }

    btnLoadTrack.addEventListener("click", () => audioFileInput.click());
    audioFileInput.addEventListener("change", (e) =>
      loadAudioFile(e.target.files[0])
    );

    btnClearAudio.addEventListener("click", () => {
      audio.pause();
      audio.removeAttribute("src");
      audio.load();
      nowPlaying.textContent = "— none —";
      timeline.value = 0;
      timeCurrent.textContent = "0:00";
      timeTotal.textContent = "0:00";
      btnPlayPause.textContent = "Play";
    });

    btnPlayPause.addEventListener("click", togglePlayPause);

    function togglePlayPause() {
      if (!audio.src) return audioFileInput.click();
      ensureAudioContext();
      if (audio.paused) {
        audio.play();
        btnPlayPause.textContent = "Pause";
      } else {
        audio.pause();
        btnPlayPause.textContent = "Play";
      }
    }

    audio.addEventListener("loadedmetadata", () => {
      timeTotal.textContent = formatTime(audio.duration);
    });

    audio.addEventListener("timeupdate", () => {
      if (!audio.duration) return;
      const ratio = audio.currentTime / audio.duration;
      timeline.value = ratio;
      timeCurrent.textContent = formatTime(audio.currentTime);
    });

    timeline.addEventListener("input", () => {
      if (!audio.duration) return;
      const t = timeline.value * audio.duration;
      audio.currentTime = t;
      timeCurrent.textContent = formatTime(t);
    });

    volumeSlider.addEventListener("input", () => {
      audio.volume = volumeSlider.value;
    });
    audio.volume = volumeSlider.value;

    btnDlAudio.addEventListener("click", () => {
      if (!audio.src) return;
      const a = document.createElement("a");
      a.href = audio.src;
      a.download = "audio-track";
      a.click();
    });

    // space / performance hotkeys
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        togglePlayPause();
      } else if (e.key.toLowerCase() === "p") {
        performanceMode = !performanceMode;
        btnPerf.classList.toggle("primary", performanceMode);
      }
    });

    // --- Save / Load presets (simple) ---
    const PRESET_KEY = "dj-vis-preset-v1";
    btnSave.addEventListener("click", () => {
      const preset = {
        theme: themeSelect.value,
        vis: visualizerSelect.value,
        fx: fxSelect.value,
        fxStrength: fxStrengthSelect.value,
        visualizerModeActive,
        logoModeActive,
      };
      localStorage.setItem(PRESET_KEY, JSON.stringify(preset));
      btnSave.textContent = "Saved!";
      setTimeout(() => (btnSave.textContent = "SAVE"), 900);
    });

    btnLoad.addEventListener("click", () => {
      const raw = localStorage.getItem(PRESET_KEY);
      if (!raw) return;
      try {
        const preset = JSON.parse(raw);
        themeSelect.value = preset.theme || "Neon";
        visualizerSelect.value = preset.vis || "Bars";
        fxSelect.value = preset.fx || "clean";
        fxStrengthSelect.value = preset.fxStrength || "medium";
        visualizerModeActive =
          preset.visualizerModeActive !== undefined
            ? preset.visualizerModeActive
            : true;
        logoModeActive =
          preset.logoModeActive !== undefined ? preset.logoModeActive : false;
        syncModeButtons();
        updateHudFooter();
      } catch (err) {
        console.warn("Bad preset", err);
      }
    });

    // --- Record canvas + audio to WebM (REC) ---
    btnRec.addEventListener("click", () => {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    });

    function startRecording() {
      if (!audioCtx) ensureAudioContext();
      try {
        const canvasStream = canvas.captureStream(60);
        const dest = audioCtx.createMediaStreamDestination();
        analyser.connect(dest);
        const combined = new MediaStream([
          ...canvasStream.getVideoTracks(),
          ...dest.stream.getAudioTracks(),
        ]);
        mediaRecorder = new MediaRecorder(combined, {
          mimeType: "video/webm;codecs=vp9",
        });
        recordedChunks = [];
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) recordedChunks.push(e.data);
        };
        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: "video/webm" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "dj-visualizer.webm";
          a.click();
          URL.revokeObjectURL(url);
        };
        mediaRecorder.start();
        isRecording = true;
        btnRec.textContent = "REC ●";
        btnRec.classList.add("primary");
      } catch (err) {
        console.error(err);
        alert("Recording is not supported in this browser.");
      }
    }

    function stopRecording() {
      if (!mediaRecorder || !isRecording) return;
      mediaRecorder.stop();
      isRecording = false;
      btnRec.textContent = "REC";
      btnRec.classList.remove("primary");
    }

    // --- Take PNG screenshot ---
    btnDlPng.addEventListener("click", () => {
      const a = document.createElement("a");
      a.href = canvas.toDataURL("image/png");
      a.download = "visualizer.png";
      a.click();
    });

    // --- GLITCH configuration ---
    const FX_STRENGTH = {
      soft: { probability: 0.12, maxOffset: 6, maxRot: 0.04 },
      medium: { probability: 0.22, maxOffset: 10, maxRot: 0.08 },
      hard: { probability: 0.33, maxOffset: 16, maxRot: 0.15 },
    };

    // --- VIS drawing helpers ---
    function drawBackground(theme) {
      const { width, height } = canvas;
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      if (theme === "Sunset") {
        grad.addColorStop(0, "#30183a");
        grad.addColorStop(0.45, "#0b1f3b");
        grad.addColorStop(1, "#02030a");
      } else if (theme === "Dark") {
        grad.addColorStop(0, "#111319");
        grad.addColorStop(0.4, "#070914");
        grad.addColorStop(1, "#020308");
      } else {
        // Neon
        grad.addColorStop(0, "#111a33");
        grad.addColorStop(0.4, "#061124");
        grad.addColorStop(1, "#02030a");
      }
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);

      // Scanlines
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      for (let y = 0; y < height; y += 4) {
        ctx.fillRect(0, y, width, 1);
      }

      // Vignette
      const rad = ctx.createRadialGradient(
        width / 2,
        height / 2,
        0,
        width / 2,
        height / 2,
        width / 1.2
      );
      rad.addColorStop(0, "rgba(0,0,0,0)");
      rad.addColorStop(1, "rgba(0,0,0,0.85)");
      ctx.fillStyle = rad;
      ctx.fillRect(0, 0, width, height);
    }

    function getAudioEnergy() {
      if (!analyser) return 0;
      analyser.getByteFrequencyData(freqData);
      let sum = 0;
      for (let i = 0; i < freqData.length; i++) sum += freqData[i];
      return sum / (freqData.length * 255);
    }

    function drawBars(energy) {
      if (!analyser) return;
      analyser.getByteFrequencyData(freqData);
      const { width, height } = canvas;
      const barCount = 80;
      const barWidth = (width * 0.6) / barCount;
      const centerX = width * 0.23;
      const centerY = height * 0.5;

      ctx.save();
      ctx.translate(centerX, centerY);

      for (let i = 0; i < barCount; i++) {
        const idx = Math.floor((i / barCount) * freqData.length);
        const v = freqData[idx] / 255;
        const barH = v * (height * 0.4);
        const x = (i - barCount * 0.1) * barWidth * 0.9;
        const y = -barH / 2;

        const hue = 185 + v * 45;
        const sat = 80 + v * 20;
        const light = 60 + v * 20;
        const alpha = 0.9;

        ctx.fillStyle = `hsla(${hue},${sat}%,${light}%,${alpha})`;
        const radius = barWidth * 0.45;
        const h = barH;

        ctx.beginPath();
        ctx.moveTo(x - radius, y);
        ctx.lineTo(x + radius, y);
        ctx.quadraticCurveTo(x + radius, y, x + radius, y + radius);
        ctx.lineTo(x + radius, y + h - radius);
        ctx.quadraticCurveTo(
          x + radius,
          y + h,
          x,
          y + h + radius * 1.5
        );
        ctx.quadraticCurveTo(
          x - radius,
          y + h,
          x - radius,
          y + h - radius
        );
        ctx.lineTo(x - radius, y + radius);
        ctx.quadraticCurveTo(x - radius, y, x - radius, y);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();
    }

    function drawCircleSpectrum(energy) {
      if (!analyser) return;
      analyser.getByteFrequencyData(freqData);
      const { width, height } = canvas;
      const cx = width * 0.5;
      const cy = height * 0.52;
      const baseR = Math.min(width, height) * 0.16;
      const maxExtra = baseR * 0.6;

      ctx.save();
      ctx.translate(cx, cy);

      // Outer arc
      ctx.beginPath();
      ctx.arc(0, 0, baseR, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 3;
      ctx.stroke();

      const bars = 180;
      for (let i = 0; i < bars; i++) {
        const idx = Math.floor((i / bars) * freqData.length);
        const v = freqData[idx] / 255;
        const ang = (i / bars) * Math.PI * 2;
        const r1 = baseR + 4;
        const r2 = baseR + 4 + v * maxExtra;

        const x1 = Math.cos(ang) * r1;
        const y1 = Math.sin(ang) * r1;
        const x2 = Math.cos(ang) * r2;
        const y2 = Math.sin(ang) * r2;

        const hue = 185 + v * 40;
        const sat = 70 + v * 30;
        const light = 55 + v * 20;
        ctx.strokeStyle = `hsla(${hue},${sat}%,${light}%,0.9)`;
        ctx.lineWidth = 2.4;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawWaveform(energy) {
      if (!analyser) return;
      analyser.getByteTimeDomainData(freqData);
      const { width, height } = canvas;
      const cx = width * 0.5;
      const cy = height * 0.76;

      ctx.save();
      ctx.translate(cx, cy);

      const len = freqData.length;
      const spread = width * 0.5;

      ctx.beginPath();
      for (let i = 0; i < len; i++) {
        const t = (i / (len - 1)) * 2 - 1;
        const x = t * spread;
        const v = (freqData[i] - 128) / 128;
        const y = v * (height * 0.16);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "rgba(196, 112, 255,0.85)";
      ctx.lineWidth = 3;
      ctx.shadowColor = "rgba(196,112,255,0.9)";
      ctx.shadowBlur = 12;
      ctx.stroke();

      ctx.restore();
      ctx.shadowBlur = 0;
    }

    // --- Logo drawing: clean ---
    function drawLogoClean() {
      if (!logoImage || logoCanvas.width === 0) return;
      const { width, height } = canvas;
      const logoW = logoCanvas.width;
      const logoH = logoCanvas.height;
      const targetW = Math.min(width * 0.35, logoW);
      const scale = targetW / logoW;
      const drawW = logoW * scale * logoScale;
      const drawH = logoH * scale * logoScale;

      const x = width * 0.63 - drawW / 2;
      const y = height * 0.5 - drawH / 2;

      ctx.save();
      ctx.globalAlpha = 0.98;
      ctx.drawImage(logoCanvas, x, y, drawW, drawH);
      ctx.restore();
    }

    // --- Logo GLITCH: BAR / TILE based with random flips ---
    function drawLogoGlitch(energy) {
      if (!logoImage || logoCanvas.width === 0) return;
      const strength = FX_STRENGTH[fxStrengthSelect.value] || FX_STRENGTH.medium;

      const { width, height } = canvas;
      const logoW = logoCanvas.width;
      const logoH = logoCanvas.height;
      const targetW = Math.min(width * 0.35, logoW);
      const baseScale = targetW / logoW;
      const baseW = logoW * baseScale * logoScale;
      const baseH = logoH * baseScale * logoScale;

      const baseX = width * 0.63 - baseW / 2;
      const baseY = height * 0.5 - baseH / 2;

      // Draw base logo (clean)
      ctx.save();
      ctx.drawImage(logoCanvas, baseX, baseY, baseW, baseH);
      ctx.restore();

      // Glitch tiles overlay
      const tilesX = 14;
      const tilesY = 6;
      const sw = logoCanvas.width / tilesX;
      const sh = logoCanvas.height / tilesY;

      const maxOffset = strength.maxOffset * (0.5 + energy);
      const maxRot = strength.maxRot * (0.5 + energy);
      const probability = strength.probability * (0.5 + energy * 1.5);

      for (let ty = 0; ty < tilesY; ty++) {
        for (let tx = 0; tx < tilesX; tx++) {
          if (Math.random() > probability) continue;

          const sx = tx * sw;
          const sy = ty * sh;

          // Destination tile position (aligned to baseline)
          const dxBase = baseX + (sx / logoCanvas.width) * baseW;
          const dyBase = baseY + (sy / logoCanvas.height) * baseH;
          const dw = (sw / logoCanvas.width) * baseW;
          const dh = (sh / logoCanvas.height) * baseH;

          // Random small offset
          const offX = (Math.random() * 2 - 1) * maxOffset;
          const offY = (Math.random() * 2 - 1) * maxOffset * 0.6;

          const centerX = dxBase + dw / 2 + offX;
          const centerY = dyBase + dh / 2 + offY;

          ctx.save();
          ctx.translate(centerX, centerY);

          // Small rotation
          const rot =
            (Math.random() * 2 - 1) *
            maxRot *
            (0.4 + energy * 1.6);
          ctx.rotate(rot);

          // Decide if we flip this tile
          let flipX = false;
          let flipY = false;
          const r = Math.random();
          if (r < 0.2) flipX = true;
          else if (r < 0.35) flipY = true;

          const scaleX = flipX ? -1 : 1;
          const scaleY = flipY ? -1 : 1;
          ctx.scale(scaleX, scaleY);

          // Slight alpha variation
          const alpha = 0.65 + Math.random() * 0.3;
          ctx.globalAlpha = alpha;

          ctx.drawImage(
            logoCanvas,
            sx,
            sy,
            sw,
            sh,
            -dw / 2,
            -dh / 2,
            dw,
            dh
          );
          ctx.restore();
        }
      }

      // Occasional global tint streaks
      if (Math.random() < 0.09 * (0.5 + energy)) {
        const streakH = baseH * (0.08 + Math.random() * 0.15);
        const offsetY =
          baseY +
          Math.random() * (baseH - streakH);
        const grad = ctx.createLinearGradient(baseX, offsetY, baseX + baseW, offsetY);
        grad.addColorStop(0, "rgba(0,255,255,0.0)");
        grad.addColorStop(0.5, "rgba(255,255,255,0.16)");
        grad.addColorStop(1, "rgba(255,0,255,0.0)");
        ctx.fillStyle = grad;
        ctx.fillRect(baseX - 18, offsetY, baseW + 36, streakH);
      }
    }

    // --- Main render loop ---
    let lastTime = 0;
    function render(now) {
      requestAnimationFrame(render);
      const dt = (now - lastTime) / 1000 || 0;
      lastTime = now;

      const theme = themeSelect.value;
      drawBackground(theme);

      const energy = getAudioEnergy();

      if (visualizerModeActive) {
        const mode = visualizerSelect.value;
        if (mode === "Bars") drawBars(energy);
        else if (mode === "Circle") drawCircleSpectrum(energy);
        else if (mode === "Waveform") drawWaveform(energy);
      }

      const fxMode = fxSelect.value;

      if (logoModeActive && logoImage) {
        if (fxMode === "glitch") drawLogoGlitch(energy);
        else drawLogoClean();
      }

      // Gentle noise overlay for CRT feel
      ctx.save();
      const { width, height } = canvas;
      const noiseAlpha = 0.05 + energy * 0.08;
      ctx.globalAlpha = noiseAlpha;
      for (let i = 0; i < 80; i++) {
        const w = 2 + Math.random() * 8;
        const h = 1 + Math.random() * 6;
        const x = Math.random() * width;
        const y = Math.random() * height;
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.fillRect(x, y, w, h);
      }
      ctx.restore();
    }
    requestAnimationFrame(render);

    updateHudFooter();
  </script>
</body>
</html>
